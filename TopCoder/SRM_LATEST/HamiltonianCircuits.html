<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>
Consider a directed graph G on <b>n</b> vertices (labeled 0, 1, 2, ..., <b>n</b>-1) with exactly <b>n</b>*(<b>n</b>-1)/2 edges:
for every pair of distinct vertices (i, j) there is either an edge from i to j or an edge from j to i, but not both.
(Hence, if we ignore the orientation of edges, G is a complete graph.)
</p>
<br></br>

<p>
Let X be a vector &lt;string&gt; that contains the adjacency matrix of G.
More precisely, X[i][j] = '+' denotes that G contains an edge from i to j, and X[i][j] = '-' denotes that there is no such edge.
On the diagonal we have X[i][i] = '.' denoting that there are no self-loops in G.
</p>
<br></br>

<p>
A Hamiltonian circuit in G is a cycle of length <b>n</b> that contains each vertex of G exactly once.
Find and return a Hamiltonian circuit in G.
More precisely, return a vector &lt;int&gt; of length <b>n</b>: the order of vertices on one Hamiltonian circuit in G.
All valid Hamiltonian circuits will be accepted.
If G does not contain any Hamiltonian circuits, return an empty vector &lt;int&gt; instead.
</p>
<br></br>

<p>
In order to keep the input small, the array X is generated from the input parameters as described below.
</p>
<br></br>

<p>
You are given the following inputs:
</p>
<ul>
<li>The int <b>n</b>: the number of vertices.</li>
<li>The ints <b>seed</b>, <b>a</b>, <b>b</b>, and <b>c</b>. These are used to generate pseudorandom directions of all edges.</li>
<li>The vector &lt;int&gt;s <b>d</b> and <b>e</b>. These are used later to specify the directions of some edges.</li>
</ul>

<p>
Use the following pseudocode to generate X:
</p>

<pre>
    value := seed
    for i = 0 .. n-1:
        X[i][i] := '.'
        for j = i+1 .. n-1:
            if (value MOD 1000) &lt;= 250:
                X[i][j] := '+' and X[j][i] := '-' // edge from i to j.
            else
                X[i][j] := '-' and X[j][i] := '+' // edge from j to i.
            value := (a * value + b) MOD c
    m := length of d
    for k = 0 .. m-1:
        X[d[k]][e[k]] := '+'
        X[e[k]][d[k]] := '-'
</pre>
</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>HamiltonianCircuits</td></tr><tr><td>Method:</td><td>findCircuit</td></tr><tr><td>Parameters:</td><td>int, int, int, int, int, vector &lt;int&gt;, vector &lt;int&gt;</td></tr><tr><td>Returns:</td><td>vector &lt;int&gt;</td></tr><tr><td>Method signature:</td><td>vector &lt;int&gt; findCircuit(int n, int seed, int a, int b, int c, vector &lt;int&gt; d, vector &lt;int&gt; e)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Notes</h3></td></tr><tr><td align="center" valign="top">-</td><td>The reference solution does not depend on any properties of the pseudorandom generator. It should solve any test case with <b>n</b> &le; 1000 within the given limits.</td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>n</b> will be between 3 and 1,000, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>seed</b> will be between 1 and 10^9, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>a</b> will be between 1 and 10^9, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>b</b> will be between 1 and 10^9, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>c</b> will be between 1 and 10^9, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>d</b> will contain between 1 and 1,000 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>e</b> will contain between 1 and 1,000 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>d</b> and <b>e</b> will contain the same number of elements.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>d</b> will be between 0 and <b>n</b>-1.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>e</b> will be between 0 and <b>n</b>-1.</td></tr><tr><td align="center" valign="top">-</td><td><b>d</b>[i] != <b>e</b>[i] for all i.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>3</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>{0,0,1}</pre></td></tr><tr><td><pre>{1,2,2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: { }</pre></td></tr><tr><td><table><tr><td colspan="2">The pseudocode will generate the following adjacency matrix X:
<pre>
.++
-.+
--.
</pre>
In this graph there is no Hamiltonian circuit.
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>4</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>{0,1,1,2,3,3}</pre></td></tr><tr><td><pre>{3,0,2,0,1,2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {1, 2, 0, 3 }</pre></td></tr><tr><td><table><tr><td colspan="2">For this input X looks as follows:
<pre>
.--+
+.+-
+-.-
-++.
</pre>
This graph has a single Hamiltonian circuit, but as you may start in any of its vertices, there are four correct outputs:
<pre>
{0, 3, 1, 2}
{1, 2, 0, 3}
{2, 0, 3, 1}
{3, 1, 2, 0}
</pre>
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>4</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>{0,0,1,2,2,3,1,0}</pre></td></tr><tr><td><pre>{1,3,2,0,3,1,0,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {1, 2, 0, 3 }</pre></td></tr><tr><td><table><tr><td colspan="2">The input describes the following X:
<pre>
.+-+
-.+-
+-.+
-+-.
</pre>
Note that the edge (0, 1) appeared three times in <b>d</b> and <b>e</b> (twice as (0, 1) and once as (1, 0)), 
but according to the problem statement's pseudocode only the last appearance matters.
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>6</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>{5, 4, 4, 3, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0}</pre></td></tr><tr><td><pre>{3, 5, 2, 4, 5, 3, 0, 5, 4, 3, 2, 5, 4, 3, 1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {3, 4, 2, 0, 1, 5 }</pre></td></tr><tr><td><table><tr><td colspan="2">Here the adjacency matrix X looks as follows:
<pre>
.+-+++
-.++++
+-.+-+
---.+-
--+-.+
---+-.
</pre>
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>6</pre></td></tr><tr><td><pre>987654323</pre></td></tr><tr><td><pre>999777888</pre></td></tr><tr><td><pre>979797979</pre></td></tr><tr><td><pre>987654323</pre></td></tr><tr><td><pre>{0}</pre></td></tr><tr><td><pre>{1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: { }</pre></td></tr><tr><td><table><tr><td colspan="2">Here the adjacency matrix X looks as follows:
<pre>
.---++
+.----
++.+--
++-.+-
-++-.-
-++++.
</pre>
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>8</pre></td></tr><tr><td><pre>2018</pre></td></tr><tr><td><pre>1337</pre></td></tr><tr><td><pre>10001</pre></td></tr><tr><td><pre>10007</pre></td></tr><tr><td><pre>{0}</pre></td></tr><tr><td><pre>{2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {3, 4, 0, 1, 2, 7, 6, 5 }</pre></td></tr><tr><td><table><tr><td colspan="2">Here the adjacency matrix X looks as follows:
<pre>
.++-----
-.+--+-+
--.--+-+
+++.+---
+++-.++-
+--+-.--
++++-+.-
+--++++.
</pre>
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">6)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>50</pre></td></tr><tr><td><pre>315301770</pre></td></tr><tr><td><pre>177340464</pre></td></tr><tr><td><pre>2067825</pre></td></tr><tr><td><pre>144591777</pre></td></tr><tr><td><pre>{45,29,34,41,36,27,28,3,20,48,44,33,20,42,0,47,1,7,5,20}</pre></td></tr><tr><td><pre>{6,8,9,2,23,7,6,22,42,19,5,21,34,8,28,22,6,21,44,29}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 
{47, 45, 49, 43, 42, 40, 39, 37, 36, 35, 33, 34, 32, 31, 29, 26, 30, 28,
 25, 24, 20, 21, 16, 14, 18, 13, 11, 9, 8, 12, 10, 7, 5, 4, 3, 2, 1, 0,
 6, 15, 17, 19, 22, 23, 27, 38, 41, 44, 46, 48 }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
