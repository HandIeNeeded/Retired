<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td>A full binary tree is a rooted tree with the following property: each vertex that is not a leaf has exactly two children - a left child and a right child.
<br></br>
<br></br>
You have a full binary tree.
The tree has n vertices, numbered 0 through n-1.
You are given the vector &lt;int&gt;s <b>lef</b> and <b>rig</b> that describe the shape of the tree.
If vertex i is a leaf we have <b>lef</b>[i] = <b>rig</b>[i] = -1.
Otherwise, <b>lef</b>[i] is the left child and <b>rig</b>[i] is the right child of vertex i.
<br></br>
<br></br>
The ancestors of vertex x are the vertices on the unique path from x to the root of the tree, including x and the root.
The least common ancestor of x and y, denoted LCA(x,y), is the first vertex on the path from x to the root that is also the ancestor of y.
Equivalently, among all vertices that are ancestors of both x and y, LCA(x,y) is the one that is farthest away from the root.
<br></br>
<br></br>
We are looking for a permutation p of {0, 1, ..., n-1}.
You are given a set of m constraints this permutation has to satisfy.
More precisely, you are given the vector &lt;int&gt;s <b>a</b>, <b>b</b>, and <b>c</b>, each with m elements.
For each valid i we get one constraint: LCA( p[<b>a</b>[i]], p[<b>b</b>[i]] ) must be <b>c</b>[i].
<br></br>
<br></br>
If there is at least one permutation with the above properties, find and return one such permutation.
Otherwise, return an empty vector &lt;int&gt;.</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>BinaryTreeAndPermutation</td></tr><tr><td>Method:</td><td>findPermutation</td></tr><tr><td>Parameters:</td><td>vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;</td></tr><tr><td>Returns:</td><td>vector &lt;int&gt;</td></tr><tr><td>Method signature:</td><td>vector &lt;int&gt; findPermutation(vector &lt;int&gt; lef, vector &lt;int&gt; rig, vector &lt;int&gt; a, vector &lt;int&gt; b, vector &lt;int&gt; c)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td>n, m will be between 1 and 50, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>lef</b> and <b>rig</b> will contain exactly n elements.</td></tr><tr><td align="center" valign="top">-</td><td>For each i, <b>lef</b>[i]=<b>rig</b>[i]=-1 or (i&lt;<b>lef</b>[i],<b>rig</b>[i]&lt;n and <b>lef</b>[i] != <b>rig</b>[i]).</td></tr><tr><td align="center" valign="top">-</td><td><b>lef</b> and <b>rig</b> will describe a binary tree.</td></tr><tr><td align="center" valign="top">-</td><td><b>a</b>, <b>b</b>, <b>c</b> will contain exactly m elements.</td></tr><tr><td align="center" valign="top">-</td><td>Each element in <b>a</b>, <b>b</b>, <b>c</b> will be between 0 and n-1, inclusive.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,-1,-1}</pre></td></tr><tr><td><pre>{2,-1,-1}</pre></td></tr><tr><td><pre>{2,1}</pre></td></tr><tr><td><pre>{2,0}</pre></td></tr><tr><td><pre>{0,0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {2, 1, 0 }</pre></td></tr><tr><td><table><tr><td colspan="2">The tree looks as follows:
<pre>
  0
 / \
1   2
</pre>
We are given two constraints: LCA( p[2], p[2] ) should be 0, and LCA( p[1], p[0] ) should also be 0.
The first constraint implies that p[2] must be 0.
This leaves us with two possible permutations: {2,1,0} and {1,2,0}.
We can easily verify that they both satisfy the second constraint as well, so each of them is a valid answer.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,-1,-1}</pre></td></tr><tr><td><pre>{2,-1,-1}</pre></td></tr><tr><td><pre>{2,1}</pre></td></tr><tr><td><pre>{2,0}</pre></td></tr><tr><td><pre>{0,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: { }</pre></td></tr><tr><td><table><tr><td colspan="2">We have the same tree and the same first constraint.
The second constraint now requires that LCA( p[1], p[0] ) should be 1.
As we saw in Example 0, there is no permutation p with this property.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,-1,3,-1,-1}</pre></td></tr><tr><td><pre>{2,-1,4,-1,-1}</pre></td></tr><tr><td><pre>{3,0,0,0}</pre></td></tr><tr><td><pre>{3,1,2,4}</pre></td></tr><tr><td><pre>{0,0,0,0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {1, 3, 4, 0, 2 }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,-1,3,-1,-1}</pre></td></tr><tr><td><pre>{2,-1,4,-1,-1}</pre></td></tr><tr><td><pre>{3,0,0,1}</pre></td></tr><tr><td><pre>{3,1,2,4}</pre></td></tr><tr><td><pre>{0,0,0,0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: { }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,-1,3,-1,-1}</pre></td></tr><tr><td><pre>{2,-1,4,-1,-1}</pre></td></tr><tr><td><pre>{1,2}</pre></td></tr><tr><td><pre>{2,1}</pre></td></tr><tr><td><pre>{0,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: { }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,3,5,-1,-1,7,-1,-1,-1}</pre></td></tr><tr><td><pre>{2,4,6,-1,-1,8,-1,-1,-1}</pre></td></tr><tr><td><pre>{6,6,7,7,3,8,5,3}</pre></td></tr><tr><td><pre>{4,3,7,1,0,0,0,5}</pre></td></tr><tr><td><pre>{1,0,1,0,2,2,2,5}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {2, 0, 7, 5, 4, 8, 3, 1, 6 }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
